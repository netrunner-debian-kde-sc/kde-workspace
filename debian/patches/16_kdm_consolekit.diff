--- /dev/null
+++ b/cmake/modules/FindCkConnector.cmake
@@ -0,0 +1,59 @@
+# - Try to find the ConsoleKit connector library (libck-connector)
+# Once done this will define
+#
+#  CKCONNECTOR_FOUND - system has the CK Connector
+#  CKCONNECTOR_INCLUDE_DIR - the CK Connector include directory
+#  CKCONNECTOR_LIBRARIES - the libraries needed to use CK Connector
+
+# Copyright (c) 2008, Kevin Kofler, <kevin.kofler@chello.at>
+# modeled after FindLibArt.cmake:
+# Copyright (c) 2006, Alexander Neundorf, <neundorf@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+if (CKCONNECTOR_INCLUDE_DIR AND CKCONNECTOR_LIBRARIES)
+
+  # in cache already
+  SET(CKCONNECTOR_FOUND TRUE)
+
+else (CKCONNECTOR_INCLUDE_DIR AND CKCONNECTOR_LIBRARIES)
+
+  IF (NOT WIN32)
+    FIND_PACKAGE(PkgConfig)
+    IF (PKG_CONFIG_FOUND)
+      # use pkg-config to get the directories and then use these values
+      # in the FIND_PATH() and FIND_LIBRARY() calls
+      pkg_check_modules(_CKCONNECTOR_PC ck-connector)
+    ENDIF (PKG_CONFIG_FOUND)
+  ENDIF (NOT WIN32)
+
+  FIND_PATH(CKCONNECTOR_INCLUDE_DIR ck-connector.h
+     ${_CKCONNECTOR_PC_INCLUDE_DIRS}
+  )
+
+  FIND_LIBRARY(CKCONNECTOR_LIBRARIES NAMES ck-connector
+     PATHS
+     ${_CKCONNECTOR_PC_LIBDIR}
+  )
+
+
+  if (CKCONNECTOR_INCLUDE_DIR AND CKCONNECTOR_LIBRARIES)
+     set(CKCONNECTOR_FOUND TRUE)
+  endif (CKCONNECTOR_INCLUDE_DIR AND CKCONNECTOR_LIBRARIES)
+
+
+  if (CKCONNECTOR_FOUND)
+     if (NOT CkConnector_FIND_QUIETLY)
+        message(STATUS "Found ck-connector: ${CKCONNECTOR_LIBRARIES}")
+     endif (NOT CkConnector_FIND_QUIETLY)
+  else (CKCONNECTOR_FOUND)
+     if (CkConnector_FIND_REQUIRED)
+        message(FATAL_ERROR "Could NOT find ck-connector")
+     endif (CkConnector_FIND_REQUIRED)
+  endif (CKCONNECTOR_FOUND)
+
+  MARK_AS_ADVANCED(CKCONNECTOR_INCLUDE_DIR CKCONNECTOR_LIBRARIES)
+
+endif (CKCONNECTOR_INCLUDE_DIR AND CKCONNECTOR_LIBRARIES)
--- /dev/null
+++ b/cmake/modules/FindDBus.cmake
@@ -0,0 +1,72 @@
+# - Try to find the low-level D-Bus library
+# Once done this will define
+#
+#  DBUS_FOUND - system has D-Bus
+#  DBUS_INCLUDE_DIR - the D-Bus include directory
+#  DBUS_ARCH_INCLUDE_DIR - the D-Bus architecture-specific include directory
+#  DBUS_LIBRARIES - the libraries needed to use D-Bus
+
+# Copyright (c) 2008, Kevin Kofler, <kevin.kofler@chello.at>
+# modeled after FindLibArt.cmake:
+# Copyright (c) 2006, Alexander Neundorf, <neundorf@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+if (DBUS_INCLUDE_DIR AND DBUS_ARCH_INCLUDE_DIR AND DBUS_LIBRARIES)
+
+  # in cache already
+  SET(DBUS_FOUND TRUE)
+
+else (DBUS_INCLUDE_DIR AND DBUS_ARCH_INCLUDE_DIR AND DBUS_LIBRARIES)
+
+  IF (NOT WIN32)
+    FIND_PACKAGE(PkgConfig)
+    IF (PKG_CONFIG_FOUND)
+      # use pkg-config to get the directories and then use these values
+      # in the FIND_PATH() and FIND_LIBRARY() calls
+      pkg_check_modules(_DBUS_PC dbus-1)
+    ENDIF (PKG_CONFIG_FOUND)
+  ENDIF (NOT WIN32)
+
+  FIND_PATH(DBUS_INCLUDE_DIR dbus/dbus.h
+    ${_DBUS_PC_INCLUDE_DIRS}
+    /usr/include
+    /usr/include/dbus-1.0
+    /usr/local/include
+  )
+
+  FIND_PATH(DBUS_ARCH_INCLUDE_DIR dbus/dbus-arch-deps.h
+    ${_DBUS_PC_INCLUDE_DIRS}
+    /usr/lib${LIB_SUFFIX}/include
+    /usr/lib${LIB_SUFFIX}/dbus-1.0/include
+    /usr/lib64/include
+    /usr/lib64/dbus-1.0/include
+    /usr/lib/include
+    /usr/lib/dbus-1.0/include
+  )
+
+  FIND_LIBRARY(DBUS_LIBRARIES NAMES dbus-1 dbus
+    PATHS
+     ${_DBUS_PC_LIBDIR}
+  )
+
+
+  if (DBUS_INCLUDE_DIR AND DBUS_ARCH_INCLUDE_DIR AND DBUS_LIBRARIES)
+     set(DBUS_FOUND TRUE)
+  endif (DBUS_INCLUDE_DIR AND DBUS_ARCH_INCLUDE_DIR AND DBUS_LIBRARIES)
+
+
+  if (DBUS_FOUND)
+     if (NOT DBus_FIND_QUIETLY)
+        message(STATUS "Found D-Bus: ${DBUS_LIBRARIES}")
+     endif (NOT DBus_FIND_QUIETLY)
+  else (DBUS_FOUND)
+     if (DBus_FIND_REQUIRED)
+        message(FATAL_ERROR "Could NOT find D-Bus")
+     endif (DBus_FIND_REQUIRED)
+  endif (DBUS_FOUND)
+
+  MARK_AS_ADVANCED(DBUS_INCLUDE_DIR DBUS_ARCH_INCLUDE_DIR DBUS_LIBRARIES)
+
+endif (DBUS_INCLUDE_DIR AND DBUS_ARCH_INCLUDE_DIR AND DBUS_LIBRARIES)
--- a/kdm/backend/client.c
+++ b/kdm/backend/client.c
@@ -77,6 +77,10 @@
 /* for expiration */
 # include <time.h>
 #endif /* USE_PAM || _AIX */
+#ifdef HAVE_CKCONNECTOR
+# include <ck-connector.h>
+# include <dbus/dbus.h>
+#endif
 #ifdef HAVE_GETSPNAM
 # include <shadow.h>
 #endif
@@ -1149,6 +1153,10 @@
 static int removeSession;
 static int removeCreds;
 #endif
+#ifdef HAVE_CKCONNECTOR
+static const char *ckSessionCookie;
+static CkConnector *connector;
+#endif
 
 static GPipe ctlpipe;
 static GTalk ctltalk;
@@ -1198,6 +1206,15 @@
 	extern char **newenv; /* from libs.a, this is set up by setpenv */
 # endif
 #endif
+#ifdef HAVE_CKCONNECTOR
+	DBusError error;
+	char deviceBuf[20] = "";
+	char *device = deviceBuf;
+	dbus_bool_t isLocal;
+#ifdef XDMCP
+	const char *remoteHostName = "";
+#endif
+#endif
 	char *failsafeArgv[2];
 	char *buf, *buf2;
 	int i;
@@ -1216,6 +1233,50 @@
 	}
 #endif
 
+#ifdef HAVE_CKCONNECTOR
+#ifdef HAVE_VTS
+	if (td->serverVT > 0) {
+		/* FIXME: how does xorg construct this */
+		sprintf( device, "/dev/tty%d", td->serverVT );
+	}	
+#endif
+
+	connector = ck_connector_new();
+	if (connector) {
+		isLocal = ((td->displayType & d_location) == dLocal);
+#ifdef XDMCP
+		/* ??? td->remoteHost can be NULL even if not local. See
+		   http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=457487 */
+		if (!isLocal && td->remoteHost)
+			remoteHostName = td->remoteHost;
+#endif
+
+		dbus_error_init( &error );
+		if (!ck_connector_open_session_with_parameters( connector,
+			&error, "unix-user", &(p->pw_uid),
+			"x11-display-device", &device,
+			"x11-display", &(td->name),
+			"is-local", &isLocal,
+#ifdef XDMCP
+			"remote-host-name", &remoteHostName,
+#endif
+			NULL )) {
+			if (dbus_error_is_set( &error )) {
+				logError( "ConsoleKit open: %s\n", error.message );
+				dbus_error_free( &error );
+			} else {
+				logError( "cannot open ConsoleKit session\n" );
+			}
+			ck_connector_unref( connector );
+			V_RET;
+		}
+	} else {
+		debug( "OOM creating CkConnector\n" );
+		V_RET;
+	}
+	ckSessionCookie = ck_connector_get_cookie( connector );
+#endif
+
 	strcpy( curuser, p->pw_name ); /* Use normalized login name. */
 
 #ifndef USE_PAM
@@ -1269,6 +1330,10 @@
 	if (krbtkfile[0] != '\0')
 		env = setEnv( env, "KRBTKFILE", krbtkfile );
 #endif
+#ifdef HAVE_CKCONNECTOR
+	if (ckSessionCookie)
+		env = setEnv( env, "XDG_SESSION_COOKIE", ckSessionCookie );
+#endif
 	userEnviron = inheritEnv( env, envvars );
 	env = systemEnv( 0, curuser );
 	systemEnviron = setEnv( env, "HOME", p->pw_dir );
@@ -1685,6 +1750,9 @@
 #ifdef USE_PAM
 	int pretc;
 #endif
+#ifdef HAVE_CKCONNECTOR
+	DBusError error;
+#endif
 
 	if (removeAuth) {
 		switch (source( systemEnviron, td->reset, td_setup )) {
@@ -1759,6 +1827,23 @@
 		pamh = 0;
 	}
 #endif
+
+#ifdef HAVE_CKCONNECTOR
+	/* close ConsoleKit session */
+	if (ckSessionCookie) {
+		dbus_error_init( &error );
+		if (!ck_connector_close_session( connector, &error )) {
+			if (dbus_error_is_set( &error )) {
+				logError( "ConsoleKit close: %s\n", error.message );
+				dbus_error_free( &error );
+			} else {
+				logError( "cannot close ConsoleKit session\n" );
+			}
+		}
+		ck_connector_unref( connector );
+		ckSessionCookie = NULL;
+	}
+#endif
 }
 
 void
--- a/kdm/backend/CMakeLists.txt
+++ b/kdm/backend/CMakeLists.txt
@@ -60,6 +60,10 @@
 	${SOCKET_LIBRARIES}
 	${RESOLV_LIBRARIES}
 )
+if (CKCONNECTOR_FOUND)
+	include_directories(${CKCONNECTOR_INCLUDE_DIR} ${DBUS_INCLUDE_DIR} ${DBUS_ARCH_INCLUDE_DIR})
+	target_link_libraries( kdm ${CKCONNECTOR_LIBRARIES} ${DBUS_LIBRARIES} )
+endif (CKCONNECTOR_FOUND)
 if(UTIL_LIBRARIES)
 	target_link_libraries( kdm ${UTIL_LIBRARIES} )
 endif(UTIL_LIBRARIES)
--- a/kdm/backend/xdmcp.c
+++ b/kdm/backend/xdmcp.c
@@ -1016,6 +1016,8 @@
 			d->clientAddr = clientAddress;
 			d->clientPort = clientPort;
 			d->connectionType = connectionType;
+			d->remoteHost = networkAddressToHostname( pdpy->connectionType,
+				&pdpy->connectionAddress );
 			if (pdpy->fileAuthorization) {
 				d->authorizations = (Xauth **)Malloc( sizeof(Xauth *) );
 				if (!d->authorizations) {
--- a/kdm/CMakeLists.txt
+++ b/kdm/CMakeLists.txt
@@ -4,6 +4,17 @@
 install_pam_service(KDM)
 
 include(ConfigureChecks.cmake)
+
+macro_optional_find_package(CkConnector)
+if(CKCONNECTOR_FOUND)
+  # when building with libck-connector, we also need the low-level D-Bus API
+  find_package(DBus REQUIRED)
+endif(CKCONNECTOR_FOUND)
+
+macro_log_feature(CKCONNECTOR_FOUND "ck-connector" "The ConsoleKit connector library" "http://freedesktop.org/wiki/Software/ConsoleKit" FALSE "" "Provides ConsoleKit integration in KDM")
+
+macro_bool_to_01(CKCONNECTOR_FOUND HAVE_CKCONNECTOR)
+
 configure_file(config-kdm.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/config-kdm.h)
 
 install( FILES README DESTINATION ${DATA_INSTALL_DIR}/doc/kdm )
--- a/kdm/config-kdm.h.cmake
+++ b/kdm/config-kdm.h.cmake
@@ -123,6 +123,9 @@
 /* Define to 1 if you have the <termios.h> header file. */
 #cmakedefine HAVE_TERMIOS_H 1
 
+/* Define to 1 if the ck-connector library is found */
+#cmakedefine HAVE_CKCONNECTOR 1
+
 /* $PATH defaults set by KDM */
 #cmakedefine KDM_DEF_USER_PATH "${KDM_DEF_USER_PATH}"
 #cmakedefine KDM_DEF_SYSTEM_PATH "${KDM_DEF_SYSTEM_PATH}"
