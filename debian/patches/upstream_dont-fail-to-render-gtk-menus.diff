Author: Thomas Lübking <thomas.luebking@gmail.com>
Author: José Manuel Santamaría Lema <panfaust@gmail.com>
Origin: https://projects.kde.org/projects/kde/kde-workspace/repository/revisions/0b7e46ddd6d3894f246512429b7a03e10fb3f53d
Description: This patch fixes a bug which breaks the rendering of gtk menus
 This patch is a backport of the upstream commit 0b7e46ddd6d3894f246512429b7a03e10fb3f53d
 The patch was originally written for the 4.9 branch and needed some changes, this is the
 message of the upstream commit:

    delay unsynced window ready_for_painting state
    
    by at max 50ms (and thus trigger a full repaint with the state change)
    
    BUG: 295254
    REVIEW: 106173
    FIXED-IN: 4.9.1

--- a/kwin/client.cpp
+++ b/kwin/client.cpp
@@ -2158,6 +2158,8 @@ void Client::getSyncCounter()
 void Client::sendSyncRequest()
 {
 #ifdef HAVE_XSYNC
+    delete m_readyForPaintingTimer;
+    m_readyForPaintingTimer = 0;
     if (syncRequest.counter == None || syncRequest.isPending)
         return; // do NOT, NEVER send a sync request when there's one on the stack. the clients will just stop respoding. FOREVER! ...
 
--- a/kwin/composite.cpp
+++ b/kwin/composite.cpp
@@ -666,12 +666,22 @@ void Client::damageNotifyEvent(XDamageNo
     if (syncRequest.counter == None)   // cannot detect complete redraw, consider done now
         ready_for_painting = true;
 #else
-    ready_for_painting = true;
+    if (!ready_for_painting) {
+        ready_for_painting = true;
+    }
 #endif
 
     Toplevel::damageNotifyEvent(e);
 }
 
+void Unmanaged::damageNotifyEvent(XDamageNotifyEvent* e)
+{
+    if (!ready_for_painting) { // avoid "setReadyForPainting()" function calling overhead
+        setReadyForPainting();
+    }
+    Toplevel::damageNotifyEvent(e);
+}
+
 void Toplevel::addDamage(const QRect& r)
 {
     addDamage(r.x(), r.y(), r.width(), r.height());
--- a/kwin/effects.cpp
+++ b/kwin/effects.cpp
@@ -379,6 +379,16 @@ void EffectsHandlerImpl::slotClientAdded
 
 void EffectsHandlerImpl::slotUnmanagedAdded(Unmanaged *u)
 {
+    if (u->readyForPainting())
+        slotUnmanagedShown(u);
+    else
+        connect(u, SIGNAL(windowShown(KWin::Toplevel*)), SLOT(slotUnmanagedShown(KWin::Toplevel*)));
+}
+
+void EffectsHandlerImpl::slotUnmanagedShown(KWin::Toplevel *t)
+{
+    Q_ASSERT(dynamic_cast<Unmanaged*>(t));
+    Unmanaged *u = static_cast<Unmanaged*>(t);
     setupUnmanagedConnections(u);
     emit windowAdded(u->effectWindow());
 }
--- a/kwin/effects.h
+++ b/kwin/effects.h
@@ -183,6 +183,7 @@ protected Q_SLOTS:
     void slotDesktopChanged(int old);
     void slotClientAdded(KWin::Client *c);
     void slotUnmanagedAdded(KWin::Unmanaged *u);
+    void slotUnmanagedShown(KWin::Toplevel*);
     void slotWindowClosed(KWin::Toplevel *c);
     void slotClientActivated(KWin::Client *c);
     void slotDeletedRemoved(KWin::Deleted *d);
--- a/kwin/toplevel.cpp
+++ b/kwin/toplevel.cpp
@@ -33,7 +33,7 @@ namespace KWin
 Toplevel::Toplevel(Workspace* ws)
     : vis(NULL)
     , info(NULL)
-    , ready_for_painting(true)
+    , ready_for_painting(false)
     , client(None)
     , frame(None)
     , wspace(ws)
@@ -45,6 +45,10 @@ Toplevel::Toplevel(Workspace* ws)
     , unredirect(false)
     , unredirectSuspend(false)
 {
+    m_readyForPaintingTimer = new QTimer(this);
+    m_readyForPaintingTimer->setSingleShot(true);
+    connect(m_readyForPaintingTimer, SIGNAL(timeout()), SLOT(setReadyForPainting()));
+    m_readyForPaintingTimer->start(50);
 }
 
 Toplevel::~Toplevel()
@@ -326,6 +330,19 @@ void Toplevel::setOpacity(double new_opa
     }
 }
 
+void Toplevel::setReadyForPainting()
+{
+    if (!ready_for_painting) {
+        delete m_readyForPaintingTimer;
+        m_readyForPaintingTimer = 0;
+        ready_for_painting = true;
+        if (compositing()) {
+            addRepaintFull();
+            emit windowShown(this);
+        }
+    }
+}
+
 void Toplevel::deleteEffectWindow()
 {
     delete effect_window;
--- a/kwin/unmanaged.h
+++ b/kwin/unmanaged.h
@@ -44,6 +44,7 @@ public:
     virtual QSize clientSize() const;
     virtual QRect transparentRect() const;
 protected:
+    virtual void damageNotifyEvent(XDamageNotifyEvent* e);
     virtual void debug(QDebug& stream) const;
     virtual bool shouldUnredirect() const;
 private:
--- a/kwin/toplevel.h
+++ b/kwin/toplevel.h
@@ -168,6 +168,7 @@ signals:
     void geometryChanged();
     void geometryShapeChanged(KWin::Toplevel* toplevel, const QRect& old);
     void windowClosed(KWin::Toplevel* toplevel, KWin::Deleted* deleted);
+    void windowShown(KWin::Toplevel* toplevel);
 
 protected:
     virtual ~Toplevel();
@@ -202,7 +203,10 @@ protected:
     int bit_depth;
     NETWinInfo2* info;
     bool ready_for_painting;
+    QTimer *m_readyForPaintingTimer; 
     QRegion repaints_region; // updating, repaint just requires repaint of that area
+protected slots:                                                                   
+    void setReadyForPainting();
 private:
     static QByteArray staticWindowRole(WId);
     static QByteArray staticSessionId(WId);
